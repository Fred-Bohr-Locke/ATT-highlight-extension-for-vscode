这是att.tmLanguage.json的注释
因为json文件不支持注释，所以只能单独写了

寄存器匹配的时候，如%r8d，只匹配%r8，这个问题我不会解决，临时把所有寄存器并到一起吧
目前不加区分应该不要紧，如果寄存器要上不同的颜色，或者未来要写判断语法的插件（不太可能），再修改吧
        {"include": "#registers_64"},
		{"include": "#registers_32"},
		{"include": "#registers_16"},
		{"include": "#registers_8"},
        "registers_64": {
			"patterns": [{
				"name": "variable.att",
				"match": "%r([a-d]x|si|di|bp|sp|[8-9]|1[0-5])"
			}]
		},
        "registers_32": {
			"patterns": [{
				"name": "variable.att",
				"match": "%(e[a-d]x|esi|edi|ebp|esp|r[8-9]d|r1[0-5]d)"
			}]
		},
        "registers_16": {
			"patterns": [{
				"name": "variable.att",
				"match": "%([a-d]x|si|di|bp|sp|r[8-9]w|r1[0-5]w)"
			}]
		},
        "registers_8": {
			"patterns": [{
				"name": "variable.att",
				"match": "%([a-d]l|sil|dil|bpl|spl|r[8-9]b|r1[0-5]b)"
			}]
		}

整数运算部分原来的颜色为keyword.operator.arithmetic，不过这个颜色是白的？？所以也用了MOV的颜色
以后还是改改颜色吧，不然全是蓝的

逻辑运算原色：keyword.operator.logical

位运算原色：keyword.operator.bitwise

和寄存器同样的问题出现了，$0xa，只匹配$0，暂时把十位和十六位数并起来了
        {"include": "#immediate_10"},
		{"include": "#immediate_16"},
        "immediate_10": {
			"patterns": [{
				"name": "constant.numeric.integer.decimal.att",
				"match": "\\$?-?[0-9]+"
			}]
		},
		"immediate_16": {
			"patterns": [{
				"name": "constant.numeric.integer.hexadecimal.att",
				"match": "\\$?0x([0-9a-fA-F]{1,16}),?"
			}]
		}

SET原色：keyword.operator

JMP原色：entity.name.label

COMV原色：keyword.operator

标点符号就是不变色，不过本来也就没有颜色，先不管了
		{"include": "punctuations"}
        "punctuations": {
			"patterns": [{
				"name": "punctuation.separator.att",
				"match": ","
			}]
		}


0.0.1注释
category目录下要加,"Themes"
contributes目录下：
        "themes": [{
            "label": "att",
            "uiTheme": "vs-dark",
            "path": "./themes/color-color-theme.json"
        }],
首先可以试试看在contributions添加scopeName：source.s （不行）
其次可以直接添加activationEvents：“onLanguage：s/att？” （目前也不行）
重新创建一个配套插件？？？（我觉得不一定能解决问题，但是还是值得试一下的）

address的begin是四个空格，不会匹配

不知道要怎么匹配十六进制命令
完全不知道要怎么区分地址、指令和立即数
先保留这个问题

改好了function的匹配方式~
Disassembly of section .plt.got:
但是这一整句都会被匹配到，这可能不太好
为了c编译后的文件的高亮，只能先保留这个匹配方案了